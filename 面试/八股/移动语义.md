移动语义应用于 **明确不再需要当前资源** 的对象（包括**临时对象**或**通过move显式标记的左值**）。


```c++
class a {
public:
	a(int* a) : a_(a) {

	}
	a(a&& a) {
			a_ = a.a_;
			a.a_ = nullptr;
	}
	int* a_;
};

void solve ( ) {
	int c = 7;
	a b(&c);
	a d(std::move(b));
	std::cout<<d.a_<<"\n";
	std::cout<<b.a_;
}
```

![[Pasted image 20250430140357.png]]

可以看到,将b移动构造给d,把b的数据均传递给d,并将b的数据置空,这就是移动语义,即转交权限

错误代码:

```c++
class a {
public:
	a ( int* a ) : a_(a) {
	}

	a ( a &a ) {
		a_ = a.a_;
		a.a_ = nullptr;
	}

	int* a_;
};

void solve ( ) {
	int c = 7;
	a b(&c);
	a d(b);
	std::cout << d.a_ << "\n";
	std::cout << b.a_;
}

// 通过普通构造函数意外破坏了原始对象
// 移动语义应只对即将销毁的临时对象实施这种操作
// 结论：虽然代码实现了指针转移，但因参数类型错误和调用方式不匹配，本质上是一个修改源对象的危险拷贝操作，而非标准移动语义。
```

这段代码看似和移动语义实现的功能一样,但是这是不安全的,拷贝构造是建立在不改变调用对象的前提下去构造另一个对象,一般是使用const左值引用以实现拷贝构造

左值引用传参是无消耗的,但是不代表拷贝构造是无消耗的,拷贝构造内部需要创建传入对象的内容给调用对象,虽然说传入对象(左值引用)是无消耗的,但是一般不能更改传入对象,又要给调用对象赋值,所以会在调用对象的数据成员上有额外消耗

右值引用传参是无消耗的,且移动构造是无消耗的,移动构造主要是为了**明确不再需要当前资源**的资源转移,所以可以将传入的对象的资源既赋值给调用对象的资源,又可以将传入对象的资源释放,可以看做是将传入资源传递给调用资源,本质上是无消耗的.